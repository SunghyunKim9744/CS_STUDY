<h2 id="프로세스">프로세스</h2>
<ul>
  <li>실행중인 프로그램</li>
  <li>운영체제가 관리하는 작업의 단위</li>
  <li>프로세스가 필요로하는 자원
    <ul>
      <li>CPU time</li>
      <li>memory</li>
      <li>files</li>
      <li>I/O devices</li>
    </ul>
  </li>
  <li>
    <p>프로세스의 메모리 영역</p>

    <ul>
      <li>text : code</li>
      <li>data : 전역 변수</li>
      <li>heap : 동적으로 할당되는 메모리</li>
      <li>stack : 지역 변수</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/70308853/128862032-26c041d4-acaa-4ea6-889d-af7a58e864f5.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/70308853/128863075-56dcc15e-5385-44ef-a3fb-090009baee62.png" alt="image" /></p>

<hr />
<h2 id="프로세스-life-cycle"><strong>프로세스 Life Cycle</strong></h2>

<p><img src="https://user-images.githubusercontent.com/70308853/128863477-11b6331b-f303-4235-9e8d-558482212e97.png" alt="image" /></p>

<ul>
  <li>New : 프로세스가 생성된 상태</li>
  <li>Ready : CPU 점유를 준비하는 상태</li>
  <li>Runnig : CPU를 점유하여 실행되고 있는 상태</li>
  <li>Waiting : I/O 완료 또는 수신 신호를 기다리는 상태</li>
  <li>Terminated : 프로세스 종료
    <ul>
      <li>scheduler dispatch : OS가 CPU를 할당해주는 것</li>
    </ul>
  </li>
</ul>

<hr />
<h2 id="프로세스의-관리">프로세스의 관리</h2>
<ul>
  <li>PCB(Process Control Block) = TCB(Task Control Block)
    <ul>
      <li>프로세스가 갖고 있는 정보를 저장
        <ul>
          <li>Process state : ex) new, ready, …</li>
          <li>Program counter : 메모리에 로드되어 있는 명령어 주소</li>
          <li>CPU registers : ex) PC, IR, DR</li>
          <li>CPU-scheduling 정보</li>
          <li>Memory-management 정보</li>
          <li>Accounting 정보</li>
          <li>I/O status 정보</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/70308853/128986625-6a83a83b-e722-4d9a-b21a-95a648578437.png" alt="image" /></p>

<hr />
<h2 id="thread쓰레드">Thread(쓰레드)</h2>
<ul>
  <li>프로그램이 복잡해지면서 프로그램 내부에서 작업을 나눔, 즉 프로세스의 작업 단위</li>
  <li>일반적으로 멀티 프로세스보단 멀티 쓰레드가 장점이 많음</li>
</ul>

<hr />
<h2 id="multiprogramming">Multiprogramming</h2>
<ul>
  <li>
    <p><strong>동시</strong>에 실행되는 프로세스</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cf) 병렬과 다름!
</code></pre></div>    </div>
  </li>
  <li>
    <p>CPU의 사용을 극대화하기 위해 사용</p>
  </li>
</ul>

<hr />
<h2 id="time-sharing">Time Sharing</h2>
<ul>
  <li>프로세스 간의 CPU-core를 자주 변경</li>
  <li>사용자는 각 프로그램이 동시에 실행되는 것처럼 느낌</li>
  <li>
    <p>이를 위해 CPU를 Scheduling 해줘야함</p>

    <ul>
      <li>Scheduling Queues
<img src="https://user-images.githubusercontent.com/70308853/129000611-43c27bc1-e67b-4900-ae77-732c3a922e3b.png" alt="image" />
        <ul>
          <li>Ready Queue에서 꺼내옴</li>
          <li>Waiting Queue</li>
        </ul>

        <p><img src="https://user-images.githubusercontent.com/70308853/129001354-6c87e6ce-c674-48b4-a8eb-26775411e34b.png" alt="image" /></p>
      </li>
    </ul>
  </li>
</ul>

<hr />
<h2 id="context-switch">Context Switch</h2>
<p><img src="https://user-images.githubusercontent.com/70308853/129015300-c9bae333-7cf0-4920-a99e-18e978b06cfd.png" alt="image" /></p>

<ul>
  <li>Context - &gt; PCB에 저장되어 있는 프로세스의 상태 정보와 CPU 레지스터 정보</li>
  <li>Interrupt 발생시 - &gt; 현재 실행되고 있는(Running상태) Context 저장 - &gt; 저장된 정보를 기반으로 이후부터 실행</li>
</ul>

<hr />
<h2 id="os와-process">OS와 Process</h2>
<ul>
  <li>OS는 반드시 프로세스의 <strong>생성</strong>과 <strong>종료</strong>를 제공해야 함</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/70308853/129022305-6c692fbe-6089-4116-b1ef-3fb81185ab0d.png" alt="image" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 부모 프로세스와 자식 프로세스의 구조
</code></pre></div></div>

<ul>
  <li>
    <p>프로세스 실행 종류</p>

    <ol>
      <li>부모와 자식 프로세스가 동시에 실행됨</li>
      <li>부모는 wait 상태로 자식이 종료될 때까지 기다림</li>
    </ol>
  </li>
  <li>
    <p>프로세스 주소 공간 종류</p>

    <ol>
      <li>부모와 같은 작업을 할경우 같은 주소 공간(PCB만 새로 만듬)</li>
      <li>새로운 주소 공간</li>
    </ol>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/70308853/129023894-1286606c-363b-47eb-b7da-3faaef21c549.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/70308853/129024206-8a105782-2327-4d64-9217-79315dc07543.png" alt="image" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fork() : 프로세스 생성 System Call
부모 프로세스의 fork 반환 값 : 자식 프로세스의 id값
자식 프로세스의 반환 값 : 0
자식 프로세스는 부모 프로세스와 같은 크기를 지님
CPU 할당시간 초과 -&gt; Ready 상태로 이동 (Context Switch 발생)

cf) 자식 프로세스 무한 생성 ? X(운영체제에 의해 통제)

운영체제에서 자식 프로세스는 fork() 함수 실행 이후의 명령어로 첫 CPU할당

PCB 생성 - &gt; fork() 이후의 주소 정보 저장 - &gt; CPU할당 받을시 fork() 이후부터 실행

</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/70308853/129025976-fe6b86c1-322f-4a41-9527-28065194f482.png" alt="image" /></p>

<ul>
  <li>종료
    <ol>
      <li>return or exit() : System Call</li>
      <li>OS가 자원들 회수</li>
    </ol>
  </li>
</ul>

<hr />
<h2 id="zombie--orphan">Zombie &amp; Orphan</h2>
<ul>
  <li>
    <p>zombie process : 자식 프로세스가 종료되었지만 부모 프로세스가 상태를 회수하지 않은 상태</p>
  </li>
  <li>
    <p>orphan process : 자식 프로세스가 종료되기 전에 부모 프로세스가 종료</p>
  </li>
</ul>
